### 0X01 å‰è¨€

è¿™æ¬¡çš„ç›®æ ‡æ˜¯è¯•ç€è§£æ flask çš„è¯·æ±‚ä¸Šä¸‹æ–‡æœ¬åœ°å †æ ˆ

**æˆ‘ç­‰ä¸æ€•æºç éš¾ï¼Œä¸‡æ°´åƒå±±åªç­‰é—²ã€‚**

### 0X02 æºç 

- LocalStack

```python
_request_ctx_stack = LocalStack()


# werkzeug
class LocalStack(object):
    """This class works similar to a :class:`Local` but keeps a stack
    of objects instead.  This is best explained with an example::

        >>> ls = LocalStack()
        >>> ls.push(42)
        >>> ls.top
        42
        >>> ls.push(23)
        >>> ls.top
        23
        >>> ls.pop()
        23
        >>> ls.top
        42

    They can be force released by using a :class:`LocalManager` or with
    the :func:`release_local` function but the correct way is to pop the
    item from the stack after using.  When the stack is empty it will
    no longer be bound to the current context (and as such released).

    By calling the stack without arguments it returns a proxy that resolves to
    the topmost item on the stack.

    .. versionadded:: 0.6.1
    """

    def __init__(self):
        self._local = Local()
        self._lock = allocate_lock()

    def __release_local__(self):
        self._local.__release_local__()

    def __call__(self):
        def _lookup():
            rv = self.top
            if rv is None:
                raise RuntimeError('object unbound')
            return rv
        return LocalProxy(_lookup)

    def push(self, obj):
        """Pushes a new item to the stack"""
        self._lock.acquire()
        try:
            rv = getattr(self._local, 'stack', None)
            if rv is None:
                self._local.stack = rv = []
            rv.append(obj)
            return rv
        finally:
            self._lock.release()

    def pop(self):
        """Removes the topmost item from the stack, will return the
        old value or `None` if the stack was already empty.
        """
        self._lock.acquire()
        try:
            stack = getattr(self._local, 'stack', None)
            if stack is None:
                return None
            elif len(stack) == 1:
                release_local(self._local)
                return stack[-1]
            else:
                return stack.pop()
        finally:
            self._lock.release()

    @property
    def top(self):
        """The topmost item on the stack.  If the stack is empty,
        `None` is returned.
        """
        try:
            return self._local.stack[-1]
        except (AttributeError, IndexError):
            return None
```

å¾€è¯·æ±‚ä¸Šä¸‹æ–‡æœ¬åœ°å †æ ˆä¸­è¿›è¡Œ push å’Œ pop æ“ä½œï¼Œå…¶å®å°±æ˜¯å¯¹ä¸€ä¸ªåˆ—è¡¨è¿›è¡Œæ“ä½œã€‚

è¿™ä¸ªåˆ—è¡¨ä¿å­˜åœ¨å †æ ˆçš„ _local å±æ€§(Local ç±»çš„å®ä¾‹)ä¸­ï¼Œé‡ç‚¹è¦çœ‹è¿™ä¸ª Local ç±»çš„å®ç°

```python
class Local(object):
    __slots__ = ('__storage__', '__lock__')

    def __init__(self):
        object.__setattr__(self, '__storage__', {})
        object.__setattr__(self, '__lock__', allocate_lock())

    def __iter__(self):
        return self.__storage__.iteritems()

    def __call__(self, proxy):
        """Create a proxy for a name."""
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(get_ident(), None)

    def __getattr__(self, name):
        self.__lock__.acquire()
        try:
            try:
                return self.__storage__[get_ident()][name]
            except KeyError:
                raise AttributeError(name)
        finally:
            self.__lock__.release()

    def __setattr__(self, name, value):
        self.__lock__.acquire()
        try:
            ident = get_ident()
            storage = self.__storage__
            if ident in storage:
                storage[ident][name] = value
            else:
                storage[ident] = {name: value}
        finally:
            self.__lock__.release()

    def __delattr__(self, name):
        self.__lock__.acquire()
        try:
            try:
                del self.__storage__[get_ident()][name]
            except KeyError:
                raise AttributeError(name)
        finally:
            self.__lock__.release()
```

å®ç°åŸç†ä¸æ˜¯å¾ˆå¤æ‚ï¼Œå°±æ˜¯åˆ›å»ºä¸€ä¸ªkey æ˜¯çº¿ç¨‹ ID ã€value æ˜¯æ•°æ®çš„å­—å…¸(\_\_storage\_\_)ã€‚

æ¯æ¬¡å­˜å–æ•°æ®æ—¶ï¼Œå…ˆè·å¾—å½“å‰çº¿ç¨‹ ID ï¼Œå†å»å­—å…¸ä¸­æ‹¿åˆ°è¯¥çº¿ç¨‹å¯¹åº”çš„æ•°æ®è¿›è¡Œæ“ä½œã€‚

> æœ€åï¼Œè®©æˆ‘ä»¬æƒ³æƒ³å¦å¤–ä¸€ä¸ªé—®é¢˜â€”â€”ä¸ºä»€ä¹ˆè¦è®¾ç½®è¯·æ±‚ä¸Šä¸‹æ–‡å †æ ˆï¼Ÿ
>
> ä»¥ä¸‹æ˜¯æˆ‘çš„çŒœæµ‹ï¼š
>
> ä»ç›´è§‚ä¸Šæ¥çœ‹ï¼Œè®¾ç½®è¯·æ±‚ä¸Šä¸‹æ–‡å †æ ˆä¼¼ä¹æ˜¯è®©ä¸€ä¸ªçº¿ç¨‹å¯ä»¥å¤„ç†å¤šä¸ªè¯·æ±‚ï¼Ÿ
>
> ä¸çŸ¥é“æ˜¯ä¸æ˜¯è·Ÿåç¨‹æœ‰å…³ :)



- LocalProxy

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å†æ¥å†å‰ï¼Œæ¢ç©¶ LocalProxy çš„å®ç°

```python
class LocalProxy(object):
    """Acts as a proxy for a werkzeug local.  Forwards all operations to
    a proxied object.  The only operations not supported for forwarding
    are right handed operands and any kind of assignment.

    Example usage::

        from werkzeug import Local
        l = Local()

        # these are proxies
        request = l('request')
        user = l('user')


        from werkzeug import LocalStack
        _response_local = LocalStack()

        # this is a proxy
        response = _response_local()

    Whenever something is bound to l.user / l.request the proxy objects
    will forward all operations.  If no object is bound a :exc:`RuntimeError`
    will be raised.

    To create proxies to :class:`Local` or :class:`LocalStack` objects,
    call the object as shown above.  If you want to have a proxy to an
    object looked up by a function, you can (as of Werkzeug 0.6.1) pass
    a function to the :class:`LocalProxy` constructor::

        session = LocalProxy(lambda: get_current_request().session)

    .. versionchanged:: 0.6.1
       The class can be instanciated with a callable as well now.
    """
    # __slots__ å˜é‡ï¼Œç”¨æ¥é™åˆ¶è¯¥classèƒ½æ·»åŠ çš„å±æ€§
    __slots__ = ('__local', '__dict__', '__name__')

    def __init__(self, local, name=None):
        object.__setattr__(self, '_LocalProxy__local', local)
        object.__setattr__(self, '__name__', name)

    def _get_current_object(self):
        """Return the current object.  This is useful if you want the real
        object behind the proxy at a time for performance reasons or because
        you want to pass the object into a different context.
        """
        if not hasattr(self.__local, '__release_local__'):
            return self.__local()
        try:
            return getattr(self.__local, self.__name__)
        except AttributeError:
            raise RuntimeError('no object bound to %s' % self.__name__)

    @property
    def __dict__(self):
        try:
            return self._get_current_object().__dict__
        except RuntimeError:
            return AttributeError('__dict__')

    def __repr__(self):
        try:
            obj = self._get_current_object()
        except RuntimeError:
            return '<%s unbound>' % self.__class__.__name__
        return repr(obj)

    def __nonzero__(self):
        try:
            return bool(self._get_current_object())
        except RuntimeError:
            return False

    def __unicode__(self):
        try:
            return unicode(self._get_current_object())
        except RuntimeError:
            return repr(self)

    def __dir__(self):
        try:
            return dir(self._get_current_object())
        except RuntimeError:
            return []

    def __getattr__(self, name):
        if name == '__members__':
            return dir(self._get_current_object())
        return getattr(self._get_current_object(), name)

    def __setitem__(self, key, value):
        self._get_current_object()[key] = value

    def __delitem__(self, key):
        del self._get_current_object()[key]

    def __setslice__(self, i, j, seq):
        self._get_current_object()[i:j] = seq

    def __delslice__(self, i, j):
        del self._get_current_object()[i:j]

    __setattr__ = lambda x, n, v: setattr(x._get_current_object(), n, v)
    __delattr__ = lambda x, n: delattr(x._get_current_object(), n)
    __str__ = lambda x: str(x._get_current_object())
    __lt__ = lambda x, o: x._get_current_object() < o
    __le__ = lambda x, o: x._get_current_object() <= o
    __eq__ = lambda x, o: x._get_current_object() == o
    __ne__ = lambda x, o: x._get_current_object() != o
    __gt__ = lambda x, o: x._get_current_object() > o
    __ge__ = lambda x, o: x._get_current_object() >= o
    __cmp__ = lambda x, o: cmp(x._get_current_object(), o)
    __hash__ = lambda x: hash(x._get_current_object())
    __call__ = lambda x, *a, **kw: x._get_current_object()(*a, **kw)
    __len__ = lambda x: len(x._get_current_object())
    __getitem__ = lambda x, i: x._get_current_object()[i]
    __iter__ = lambda x: iter(x._get_current_object())
    __contains__ = lambda x, i: i in x._get_current_object()
    __getslice__ = lambda x, i, j: x._get_current_object()[i:j]
    __add__ = lambda x, o: x._get_current_object() + o
    __sub__ = lambda x, o: x._get_current_object() - o
    __mul__ = lambda x, o: x._get_current_object() * o
    __floordiv__ = lambda x, o: x._get_current_object() // o
    __mod__ = lambda x, o: x._get_current_object() % o
    __divmod__ = lambda x, o: x._get_current_object().__divmod__(o)
    __pow__ = lambda x, o: x._get_current_object() ** o
    __lshift__ = lambda x, o: x._get_current_object() << o
    __rshift__ = lambda x, o: x._get_current_object() >> o
    __and__ = lambda x, o: x._get_current_object() & o
    __xor__ = lambda x, o: x._get_current_object() ^ o
    __or__ = lambda x, o: x._get_current_object() | o
    __div__ = lambda x, o: x._get_current_object().__div__(o)
    __truediv__ = lambda x, o: x._get_current_object().__truediv__(o)
    __neg__ = lambda x: -(x._get_current_object())
    __pos__ = lambda x: +(x._get_current_object())
    __abs__ = lambda x: abs(x._get_current_object())
    __invert__ = lambda x: ~(x._get_current_object())
    __complex__ = lambda x: complex(x._get_current_object())
    __int__ = lambda x: int(x._get_current_object())
    __long__ = lambda x: long(x._get_current_object())
    __float__ = lambda x: float(x._get_current_object())
    __oct__ = lambda x: oct(x._get_current_object())
    __hex__ = lambda x: hex(x._get_current_object())
    __index__ = lambda x: x._get_current_object().__index__()
    __coerce__ = lambda x, o: x.__coerce__(x, o)
    __enter__ = lambda x: x.__enter__()
    __exit__ = lambda x, *a, **kw: x.__exit__(*a, **kw)
```

çœ‹äº†åŠå¤©æ²¡æœ‰ææ˜ç™½å®ƒçš„ __local å±æ€§åˆ°åº•æ˜¯åœ¨å“ªé‡Œè®¾ç½®çš„ï¼Œä¸Šç™¾åº¦

åŸæ¥åœ¨Pythonä¸­ï¼Œå½“ä½ è®¿é—®åŒä¸‹åˆ’çº¿å¼€å¤´çš„å±æ€§ï¼Œå®ƒä¼šè¿›è¡Œæ”¹å

ä¾‹å¦‚åœ¨è¿™é‡Œï¼Œ å½“ä½ è®¿é—® `self.__local` æ—¶ï¼Œå…¶å®æ˜¯åœ¨è®¿é—® `self._LocalProxy__local`

å³åœ¨å‰é¢åŠ  `_<ç±»å>` ï¼ˆè¿™é‡Œæ˜¯çœŸçš„ç…ç¬”äº†ï¼‰

ä»£ç å¦‚å…¶åï¼Œå°±æ˜¯è½¬å‘å‚æ•°ç»™å½“å‰å¯¹è±¡ã€‚

> å…³äºä¸ºä»€ä¹ˆè®¾ç½®ä»£ç†ï¼Ÿ
>
> æˆ‘ä»¬çŸ¥é“ requestã€ sessionã€ g éƒ½æ˜¯ä¿å­˜åœ¨è¯·æ±‚ä¸Šä¸‹æ–‡(_RequestContextç±»)ä¸­çš„ï¼Œè€Œè¯·æ±‚ä¸Šä¸‹æ–‡æ˜¯åœ¨å¤„ç†è¯·æ±‚æ—¶åˆ›å»ºçš„ã€‚ä¹Ÿå°±æ˜¯è¯´æ²¡æœ‰æ”¶åˆ°è¯·æ±‚æ—¶ï¼Œrequestã€sessionã€g éƒ½æ˜¯ä¸å­˜åœ¨çš„
>
> ä»£ç†çš„æ¯ä¸ªæ“ä½œéƒ½éœ€è¦è°ƒç”¨ _get_current_object ï¼Œä»è€Œå®ç°åœ¨è¯·æ±‚ä¸Šä¸‹æ–‡åˆ›å»ºåå†è·å– request ã€session ã€g
>
> current_app åˆ™æ˜¯åœ¨æˆ‘ä»¬æœ‰å¤šä¸ª app æ—¶ï¼Œè·å–å¤„ç†å½“å‰è¯·æ±‚çš„ app ï¼Œå®ƒåŒæ ·è¢«ä¿å­˜åœ¨è¯·æ±‚ä¸Šä¸‹æ–‡ä¸­



### 0X03 åè®°

æ²¡æƒ³åˆ°å®ç°åŸç†è¿™ä¹ˆç®€å•ï¼ŒçœŸæ˜¯æ— è¯­å‡å™

è¿™æ„Ÿè§‰å°±è·Ÿæˆ‘ä»¬è¯»æ–‡ç« ä¸€æ ·â€”â€”æ¯ä¸ªå­—æˆ‘éƒ½è®¤è¯†ï¼Œä½†æˆ‘å°±æ˜¯å†™ä¸å‡ºğŸ˜‚